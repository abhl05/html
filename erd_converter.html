<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Strict Chen's Notation (Weighted & Bendable)</title>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', sans-serif; display: flex; height: 100vh; margin: 0; background-color: #f4f4f4;}
        #sidebar { width: 350px; padding: 20px; background: #ffffff; border-right: 1px solid #ddd; display: flex; flex-direction: column; box-shadow: 2px 0 5px rgba(0,0,0,0.05); z-index: 10;}
        #network { flex-grow: 1; background: #ffffff; }
        textarea { width: 100%; height: 400px; margin-bottom: 15px; font-family: 'Consolas', monospace; font-size: 12px; border: 1px solid #ccc; padding: 10px; border-radius: 4px; resize: vertical;}
        button { padding: 12px; background: #0056b3; color: white; border: none; cursor: pointer; font-weight: bold; border-radius: 4px; transition: background 0.2s; }
        button:hover { background: #004494; }
        .legend { font-size: 12px; color: #444; margin-top: 15px; border-top: 1px solid #eee; padding-top: 10px; line-height: 1.6; }
    </style>
</head>
<body>

<div id="sidebar">
    <h3>Strict Chen's Generator</h3>
    <p style="font-size: 12px; color: #666; margin-top:-10px;">
        Layout freezes after generation. Drag nodes to adjust.
    </p>
    <textarea id="dbmlInput" placeholder="Paste your DBML here...">
<!-- // Ride Share System (Strict Notation)

Table users {
  user_id int [pk]
  name varchar
  phone varchar
}

Table drivers {
  driver_id int [pk]
  license varchar
  rating decimal
}

// WEAK ENTITY EXAMPLE
Table contacts {
  Note: 'weak'
  contact_name varchar [note: 'discriminator']
  phone varchar
}

Table rides {
  ride_id int [pk]
  date datetime
  fare decimal
}

// RELATIONSHIPS

// 1. Identifying Relationship (Double Diamond)
// Note: 'identifying' triggers double diamond
Ref: users.user_id < contacts.contact_name 
Note: 'identifying' // has_contact

// 2. One-to-Many (Arrow to 'One' side)
Ref: users.user_id < rides.ride_id // requests
Ref: drivers.driver_id < rides.ride_id // conducts

// 3. Many-to-Many (Lines on both sides)
// Use dash (-) for M:N
Ref: users.user_id - drivers.driver_id // rates -->
// --- RIDE SHARE SYSTEM ERD (15 Tables) ---

// 1. CORE USERS
Table Users {
  user_id int [pk]
  name varchar
  email varchar
  rating float
}

Table Drivers {
  driver_id int [pk]
  user_id int
  license_number varchar
  status varchar // Active, Offline
}

Table Admins {
  admin_id int [pk]
  role varchar
  permissions varchar
}

// 2. VEHICLE MANAGEMENT
Table Vehicles {
  vehicle_id int [pk]
  plate_number varchar
  model varchar
  year int
}

Table VehicleTypes {
  type_id int [pk]
  name varchar // UberX, Black, XL
  base_fare decimal
}

// 3. RIDE LOGIC
Table Rides {
  ride_id int [pk]
  start_time datetime
  end_time datetime
  total_fare decimal
}

Table RideStatus {
  status_id int [pk]
  name varchar // Requested, Ongoing, Completed, Cancelled
}

// 4. FINANCIALS
Table Payments {
  payment_id int [pk]
  amount decimal
  method varchar // Card, Cash, Wallet
  status varchar
}

Table Coupons {
  coupon_id int [pk]
  code varchar
  discount_percent int
  expiry_date datetime
}

// 5. WEAK ENTITIES & SUPPORT
Table EmergencyContacts {
  Note: 'weak'
  contact_name varchar [note: 'discriminator']
  phone varchar
  relation varchar
}

Table DriverDocuments {
  Note: 'weak'
  doc_type varchar [note: 'discriminator']
  image_url varchar
  expiry_date date
}

Table ChatMessages {
  msg_id int [pk]
  content text
  timestamp datetime
}

Table SupportTickets {
  ticket_id int [pk]
  subject varchar
  description text
  priority varchar
}

Table SavedPlaces {
  place_id int [pk]
  name varchar // Home, Work
  latitude float
  longitude float
}

Table Notifications {
  notif_id int [pk]
  content varchar
  is_read boolean
}


// --- RELATIONSHIPS & CARDINALITY ---

// 1. USERS & CONTACTS (Identifying Relationship)
// A User has N contacts. Contact existence depends on User.
// Syntax: // [LeftCard, RightCard] LeftPart-RightPart Label
Ref: Users.user_id < EmergencyContacts.contact_name 
Note: 'identifying' // [1..1, 0..*] total-total has_contact

// 2. DRIVERS & DOCUMENTS (Identifying Relationship)
// A Driver must have documents to exist in the system.
Ref: Drivers.driver_id < DriverDocuments.doc_type 
Note: 'identifying' // [1..1, 1..*] total-total has_docs

// 3. DRIVERS & VEHICLES
// Driver (Total) owns (Total) Vehicle. (Assuming 1 driver - 1 car model for simplicity here)
Ref: Drivers.driver_id - Vehicles.vehicle_id // [1..1, 1..1] total-total drives

// 4. VEHICLES & TYPES
// Vehicle (Total) must have a Type. Type (Partial) can have many vehicles.
Ref: Vehicles.vehicle_id > VehicleTypes.type_id // [0..*, 1..1] total-partial is_type

// 5. RIDES & USERS (The Main Transaction)
// User (Total - assuming historical) requests Ride.
Ref: Users.user_id < Rides.ride_id // [1..1, 0..*] total-total requests

// 6. RIDES & DRIVERS
// Driver (Partial - may be idle) conducts Ride.
Ref: Drivers.driver_id < Rides.ride_id // [0..1, 0..*] partial-total conducts

// 7. RIDES & STATUS
Ref: Rides.ride_id > RideStatus.status_id // [0..*, 1..1] total-total current_status

// 8. RIDES & PAYMENTS
// 1 Ride has exactly 1 Payment.
Ref: Rides.ride_id - Payments.payment_id // [1..1, 1..1] total-total paid_via

// 9. USERS & COUPONS (Many-to-Many)
// User can have many coupons, Coupon can belong to many users.
Ref: Users.user_id - Coupons.coupon_id // [0..*, 0..*] partial-partial saves

// 10. RIDES & CHAT
// Chat messages belong to a specific Ride context.
Ref: Rides.ride_id < ChatMessages.msg_id // [1..1, 0..*] partial-total contains_chat

// 11. USERS & SAVED PLACES
Ref: Users.user_id < SavedPlaces.place_id // [1..1, 0..*] partial-total saves_location

// 12. USERS & TICKETS
Ref: Users.user_id < SupportTickets.ticket_id // [1..1, 0..*] partial-total opens_ticket

// 13. USERS & NOTIFICATIONS
Ref: Users.user_id < Notifications.notif_id // [1..1, 0..*] partial-total receives

// 14. ADMIN & TICKETS (Admin manages tickets)
Ref: Admins.admin_id < SupportTickets.ticket_id // [0..1, 0..*] partial-partial resolves
    </textarea>
    <button onclick="parseAndDraw()">Generate Diagram</button>
    <button onclick="exportERD()" style="background-color: #28a745; margin-top: 10px;">Export as PNG</button>
    <button onclick="exportHighResPDF()" style="background-color: #dc3545; margin-top: 10px;">Export Hi-Res PDF</button>
    <div style="margin-top: 20px; border-top: 1px solid #ccc; padding-top: 10px;">
        <strong>Project Management:</strong><br>
        <button onclick="saveProject()" style="background-color: #17a2b8; margin-top: 5px;">ðŸ’¾ Save Project (JSON)</button>
        <input type="file" id="loadInput" onchange="loadProject(this)" style="display: none;">
        <button onclick="document.getElementById('loadInput').click()" style="background-color: #6c757d; margin-top: 5px;">ðŸ“‚ Load Project</button>
    </div>

    <div class="legend">
        <strong>Visual Rules:</strong><br>
        â€¢ Strong Entity: Single Box<br>
        â€¢ Weak Entity: Double Box<br>
        â€¢ Strong Rel: Single Diamond<br>
        â€¢ Identifying Rel: Double Diamond<br>
        â€¢ PK: Solid Underline<br>
        â€¢ Discriminator: Dashed Underline<br>
        â€¢ Arrow ($\rightarrow$): 'One' Cardinality<br>
        â€¢ Line (â€”): 'Many' Cardinality
    </div>
</div>

<div id="network"></div>

<script>
    let network = null;

    function parseAndDraw() {
        const input = document.getElementById('dbmlInput').value;
        const data = parseDBML(input);
        drawNetwork(data);
    }

    function parseDBML(dbml) {
        const nodes = [];
        const edges = [];
        const tables = {}; 
        const tableData = {}; 
        let idCounter = 1;

        const lines = dbml.split('\n');
        let currentTable = null;

        // --- Pass 1: Tables & Columns ---
        lines.forEach(line => {
            line = line.trim();
            if (!line) return;

            const tableMatch = line.match(/Table\s+(\w+)\s*\{?/);
            if (tableMatch) {
                currentTable = tableMatch[1];
                tables[currentTable] = idCounter++;
                tableData[currentTable] = { columns: [], isWeak: false };
                return;
            }
            if (line.includes('}')) { currentTable = null; return; }

            if (currentTable) {
                if (line.toLowerCase().includes("note: 'weak'")) tableData[currentTable].isWeak = true;
                
                if (!line.startsWith('//') && !line.startsWith('Note') && !line.includes('{') && !line.includes('Ref:')) {
                    const parts = line.split(/\s+/);
                    let colName = parts[0];
                    if (colName) {
                        let isPk = line.toLowerCase().includes('[pk]') || line.toLowerCase().includes('primary key');
                        let isDiscriminator = line.toLowerCase().includes("'discriminator'");
                        tableData[currentTable].columns.push({
                            name: colName, isPk, isDiscriminator
                        });
                    }
                }
            }
        });

        // Generate Table SVG Nodes
        for (const [name, id] of Object.entries(tables)) {
            const t = tableData[name];
            const svgObj = createEntitySVG(name, t.columns, t.isWeak);
            
            nodes.push({ 
                id: id, 
                image: svgObj.url, 
                shape: 'image', 
                // REMOVED fixed 'size: 40' to allow automatic scaling via useImageSize
                hiddenLabel: name 
            });
        }

        // --- Pass 2: Relationships ---
        for (let i = 0; i < lines.length; i++) {
            let line = lines[i].trim();
            
            if (line.startsWith('Ref:')) {
                const refMatch = line.match(/Ref:\s*(\w+)\.?\w*\s*([<>=-]+)\s*(\w+)\.?\w*(.*)/);
                if (refMatch) {
                    const t1Name = refMatch[1];
                    const op = refMatch[2];
                    const t2Name = refMatch[3];
                    let comment = refMatch[4] || "";
                    
                    let label = "relates";
                    let cardLeft = "";
                    let cardRight = "";

                    const cardMatch = comment.match(/\[(.*?),(.*?)\]/);
                    
                    if (cardMatch) {
                        cardLeft = cardMatch[1].trim();
                        cardRight = cardMatch[2].trim();
                        comment = comment.replace(/\[.*?\]/, '');
                    } else {
                        if (op.includes('<')) cardLeft = "1"; else cardLeft = "N";
                        if (op.includes('>')) cardRight = "1"; else cardRight = "N";
                        if (op === '-') { cardLeft = "M"; cardRight = "N"; }
                    }

                    if (comment.includes('//')) {
                        let rawComment = comment.split('//')[1].trim();
                        label = rawComment.replace(/(total|partial)-(total|partial)/gi, '').trim();
                        if(!label) label = "relates";
                    }

                    let leftPart = 'partial';
                    let rightPart = 'partial';
                    if (comment.includes('total-total')) { leftPart = 'total'; rightPart = 'total'; }
                    else if (comment.includes('total-partial')) { leftPart = 'total'; rightPart = 'partial'; }
                    else if (comment.includes('partial-total')) { leftPart = 'partial'; rightPart = 'total'; }

                    let isIdentifying = false;
                    if (lines[i+1] && lines[i+1].includes("'identifying'")) isIdentifying = true;
                    if (comment.includes("'identifying'")) isIdentifying = true;

                    const relId = idCounter++;
                    const svgDiamond = createRelationshipSVG(label, isIdentifying);
                    nodes.push({ id: relId, shape: 'image', image: svgDiamond }); // No fixed size

                    let arrowToT1 = op.includes('<');
                    let arrowToT2 = op.includes('>');

                    // Helper: Add Edge with Masking & Labels
                    const addEdge = (from, to, hasArrow, participation, textLabel) => {
                        const isTotal = (participation === 'total');
                        const smoothConfig = { enabled: true, type: 'continuous', roundness: 0.5 };
                        const fontConfig = { size: 14, color: 'black', background: 'white', strokeWidth: 0, align: 'horizontal' };

                        if (isTotal) {
                            // Layer 1: Base Edge (Thick Black)
                            edges.push({
                                from: from, to: to,
                                width: 5, color: { color: 'black' },
                                arrows: '', smooth: smoothConfig, arrowStrikethrough: false, label: '' 
                            });

                            // Layer 2: Mask Edge (Thin White)
                            edges.push({
                                from: from, to: to,
                                width: 2, color: { color: 'white' },
                                arrows: '', smooth: smoothConfig, arrowStrikethrough: false, label: textLabel, font: fontConfig
                            });

                            // Layer 3: Arrow Carrier (Invisible Line, Black Arrow)
                            if (hasArrow) {
                                edges.push({
                                    from: from, to: to,
                                    width: 1, color: { opacity: 0 }, 
                                    arrows: { 
                                        to: { enabled: true, scaleFactor: 1.0, type: 'arrow', color: '#000000' } 
                                    },
                                    smooth: smoothConfig, arrowStrikethrough: false, label: ''
                                });
                            }
                        } else {
                            // Single Line
                            const edge = {
                                from: from, to: to,
                                width: 1.5, color: { color: 'black' },
                                smooth: smoothConfig, arrowStrikethrough: false, label: textLabel, font: fontConfig
                            };
                            if (hasArrow) {
                                edge.arrows = { to: { enabled: true, scaleFactor: 1.0, type: 'arrow' } };
                            }
                            edges.push(edge);
                        }
                    };

                    addEdge(relId, tables[t1Name], arrowToT1, leftPart, cardLeft);
                    addEdge(relId, tables[t2Name], arrowToT2, rightPart, cardRight);
                }
            }
        }

        return { nodes: new vis.DataSet(nodes), edges: new vis.DataSet(edges) };
    }

    // --- SVG Generator: Entities (UPDATED FOR COMPOSITE & SCALING) ---
    function createEntitySVG(name, columns, isWeak) {
        const lineHeight = 20; 
        const padding = 10; 
        const headerHeight = 30;
        
        // Dynamic Height Calculation
        const totalHeight = headerHeight + (columns.length * lineHeight) + (padding * 2);
        
        let maxTextLen = name.length;
        columns.forEach(c => maxTextLen = Math.max(maxTextLen, c.name.length + 5)); 
        const width = Math.max(140, maxTextLen * 10);

        const strokeColor = "#000"; const fillColor = "#E8F4F8"; const strokeWidth = 2; 
        let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${totalHeight}">`;
        
        // Box
        svg += `<rect x="2" y="2" width="${width-4}" height="${totalHeight-4}" style="fill:${fillColor};stroke:${strokeColor};stroke-width:${strokeWidth}" />`;
        if (isWeak) svg += `<rect x="6" y="6" width="${width-12}" height="${totalHeight-12}" style="fill:none;stroke:${strokeColor};stroke-width:${strokeWidth}" />`;
        
        // Header
        svg += `<text x="50%" y="${padding + 15}" dominant-baseline="middle" text-anchor="middle" font-family="sans-serif" font-weight="bold" font-size="14">${name}</text>`;
        let lineY = headerHeight + 5;
        svg += `<line x1="2" y1="${lineY}" x2="${width-2}" y2="${lineY}" style="stroke:${strokeColor};stroke-width:1" />`;

        // Columns with Composite Logic (Simple Indentation)
        let currentY = lineY + 20;
        columns.forEach(col => {
            let displayName = col.name;
            let isCompositeChild = false;
            
            // Check for dot notation (e.g. name.first)
            if (displayName.includes('.')) {
                const parts = displayName.split('.');
                displayName = parts[parts.length - 1]; 
                isCompositeChild = true;
            }

            // Indentation: Parent = 10px, Child = 30px (Simple Space)
            const xPos = isCompositeChild ? 30 : 10; 
            
            // REMOVED: Tree line drawing code

            svg += `<text x="${xPos}" y="${currentY}" font-family="monospace" font-size="12">${displayName}</text>`;
            const textWidth = displayName.length * 7.2; 
            
            if (col.isPk) svg += `<line x1="${xPos}" y1="${currentY+2}" x2="${xPos+textWidth}" y2="${currentY+2}" style="stroke:black;stroke-width:1" />`;
            else if (col.isDiscriminator) svg += `<line x1="${xPos}" y1="${currentY+2}" x2="${xPos+textWidth}" y2="${currentY+2}" style="stroke:black;stroke-width:1;stroke-dasharray:4,2" />`;
            currentY += lineHeight;
        });
        svg += `</svg>`;
        return { url: "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg) };
    }

    function createRelationshipSVG(label, isIdentifying) {
        const width = 100; const height = 60;
        const strokeColor = "#000"; const fillColor = "#FFF0F0";
        let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}">`;
        svg += `<polygon points="50,2 98,30 50,58 2,30" style="fill:${fillColor};stroke:${strokeColor};stroke-width:2" />`;
        if (isIdentifying) svg += `<polygon points="50,10 88,30 50,50 12,30" style="fill:none;stroke:${strokeColor};stroke-width:2" />`;
        svg += `<text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" font-family="sans-serif" font-size="11">${label}</text>`;
        svg += `</svg>`;
        return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
    }

    // --- Drawing Logic ---
    function drawNetwork(data) {
        const container = document.getElementById('network');
        const options = {
            nodes: {
                // FIX: useImageSize ensures nodes grow with content and font stays readable
                shapeProperties: {
                    useImageSize: true,
                    useBorderWithImage: false
                }
            },
            physics: {
                enabled: true,
                stabilization: { enabled: true, iterations: 1000 },
                barnesHut: { gravitationalConstant: -3000, springLength: 200 }
            },
            interaction: { dragNodes: true },
            edges: {
                smooth: { enabled: true, type: 'continuous', roundness: 0.5 }
            }
        };

        if (network !== null) network.destroy();
        network = new vis.Network(container, data, options);

        network.on("stabilizationIterationsDone", function () {
            network.setOptions({ physics: { enabled: false } });
        });
    }

    // --- Exports & Project Management (Unchanged) ---
    function exportERD() {
        const canvas = document.querySelector('#network canvas');
        const link = document.createElement('a');
        link.href = canvas.toDataURL('image/png');
        link.download = 'ride_share_erd.png';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    async function exportHighResPDF() {
        const { jsPDF } = window.jspdf;
        const nodeIds = network.body.data.nodes.getIds();
        if (nodeIds.length === 0) { alert("No nodes to export!"); return; }

        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        nodeIds.forEach(id => {
            const box = network.getBoundingBox(id);
            if (box.left < minX) minX = box.left;
            if (box.right > maxX) maxX = box.right;
            if (box.top < minY) minY = box.top;
            if (box.bottom > maxY) maxY = box.bottom;
        });

        const padding = 150; 
        const graphWidth = (maxX - minX) + (padding * 2);
        const graphHeight = (maxY - minY) + (padding * 2);
        const scaleFactor = 2; 
        const finalWidth = Math.ceil(graphWidth * scaleFactor);
        const finalHeight = Math.ceil(graphHeight * scaleFactor);

        network.setSize(finalWidth + 'px', finalHeight + 'px');
        
        const center_x = (minX + maxX) / 2;
        const center_y = (minY + maxY) / 2;
        
        network.moveTo({
            position: { x: center_x, y: center_y },
            scale: scaleFactor, 
            offset: { x: 0, y: 0 } 
        });
        
        network.redraw();

        setTimeout(() => {
            const originalCanvas = document.querySelector('#network canvas');
            const compositeCanvas = document.createElement('canvas');
            compositeCanvas.width = finalWidth;
            compositeCanvas.height = finalHeight;
            const ctx = compositeCanvas.getContext('2d');
            ctx.fillStyle = '#FFFFFF'; 
            ctx.fillRect(0, 0, finalWidth, finalHeight);
            ctx.drawImage(originalCanvas, 0, 0);

            const imgData = compositeCanvas.toDataURL('image/jpeg', 1.0);
            const pdf = new jsPDF(finalWidth > finalHeight ? 'l' : 'p', 'px', [finalWidth, finalHeight]);
            pdf.addImage(imgData, 'JPEG', 0, 0, finalWidth, finalHeight);
            pdf.save('ride_share_erd_tight_crop.pdf');

            network.setSize('100%', '100%');
            network.fit({ animation: false });
            network.redraw();
        }, 1000);
    }

    function saveProject() {
        const dbml = document.getElementById('dbmlInput').value;
        const positions = network.getPositions();
        const allNodes = network.body.data.nodes.get();
        const layout = {};
        allNodes.forEach(node => {
            if (positions[node.id]) {
                layout[node.id] = positions[node.id];
            }
        });
        const projectData = { timestamp: new Date().toISOString(), dbml: dbml, layout: layout };
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(projectData));
        const downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute("href", dataStr);
        downloadAnchorNode.setAttribute("download", "erd_project.json");
        document.body.appendChild(downloadAnchorNode);
        downloadAnchorNode.click();
        downloadAnchorNode.remove();
    }

    function loadProject(inputElement) {
        const file = inputElement.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const project = JSON.parse(e.target.result);
                document.getElementById('dbmlInput').value = project.dbml;
                parseAndDraw();
                setTimeout(() => {
                    if (project.layout) {
                        for (const [id, pos] of Object.entries(project.layout)) {
                            network.moveNode(id, pos.x, pos.y);
                        }
                        network.fit({ animation: true });
                    }
                }, 100);
            } catch (err) { alert("Error loading project file: " + err); }
        };
        reader.readAsText(file);
        inputElement.value = ''; 
    }

    window.onload = parseAndDraw;
</script>

</body>
</html>